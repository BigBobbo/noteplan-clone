# NotePlan Clone - Project Constitution

## 🎯 Purpose
This document defines the core principles and standards for the NotePlan clone project. All code changes, features, and decisions must align with these principles.

---

## 1. Code Quality Standards

### 1.1 Type Safety
- **All code must be strongly typed using TypeScript**
  - No `any` types except in legacy integration points (must be documented)
  - All function parameters and return types must be explicitly typed
  - Use strict TypeScript configuration (`strict: true`)
  - Type guards must be used for runtime type validation

### 1.2 Code Organization
- **Single Responsibility Principle**
  - Each component/function should have one clear purpose
  - Files should not exceed 300 lines (exceptions require justification)
  - Extract complex logic into separate services/utilities

- **Consistent File Structure**
  ```
  /frontend/src/
    /components/     - React components
    /extensions/     - Tiptap extensions
    /services/       - Business logic and data access
    /store/          - Zustand state management
    /types/          - TypeScript type definitions
    /utils/          - Pure utility functions
  ```

- **Naming Conventions**
  - Components: PascalCase (e.g., `TaskListView.tsx`)
  - Services: camelCase with suffix (e.g., `taskService.ts`)
  - Utilities: camelCase (e.g., `parseMarkdown.ts`)
  - Types/Interfaces: PascalCase with descriptive names (e.g., `NoteMetadata`)
  - Constants: UPPER_SNAKE_CASE (e.g., `DEFAULT_NOTE_PATH`)

### 1.3 Code Documentation
- **All public functions must have JSDoc comments**
  ```typescript
  /**
   * Parses a markdown file and extracts tasks in GFM format.
   * @param content - The markdown content to parse
   * @param filePath - The path to the source file
   * @returns Array of parsed tasks with metadata
   */
  ```

- **Complex logic requires inline comments explaining "why", not "what"**
- **All RegEx patterns must have explanatory comments**
- **Breaking changes require migration guides in comments**

### 1.4 Error Handling
- **Never silently fail**
  - All errors must be logged with context
  - User-facing errors must provide actionable guidance
  - Backend errors must include stack traces in development

- **Defensive Programming**
  - Validate all external inputs (user input, file reads, API responses)
  - Check for null/undefined before accessing properties
  - Provide sensible defaults for optional parameters

---

## 2. Testing Standards

### 2.1 Testing Mandate (CRITICAL)
**⚠️ ABSOLUTE RULE: NO FEATURE IS COMPLETE WITHOUT AUTOMATED TESTS**

- **Manual testing is NOT SUFFICIENT**
  - Visual appearance ≠ working functionality
  - Browser state can mask bugs
  - File persistence issues require automated verification

- **Every feature must include:**
  1. Rendering tests (element appears correctly)
  2. Interaction tests (clicks/drags/inputs work)
  3. State change tests (UI updates properly)
  4. File persistence tests (data saves to disk)
  5. Round-trip tests (load → edit → save → reload)

### 2.2 Test Coverage Requirements
- **All new features require comprehensive Playwright tests**
- **Bug fixes must include regression tests**
- **Minimum test structure:**
  ```javascript
  test.describe('Feature Name', () => {
    test('1. Feature renders correctly', async ({ page }) => { });
    test('2. User interaction works', async ({ page }) => { });
    test('3. Data persists to file', async ({ page }) => { });
    test('4. Changes survive reload', async ({ page }) => { });
  });
  ```

### 2.3 Test Validation Checklist
Before claiming ANY fix is complete:
- [ ] Automated test written and passing
- [ ] Console logs captured and validated
- [ ] File content verified on disk
- [ ] Round-trip tested (reload works)
- [ ] No TypeScript errors (`npx tsc --noEmit`)
- [ ] Full test suite passes (`npx playwright test`)

### 2.4 Test File Organization
- Test files in root: `/test-{feature}.spec.js`
- Test data files: `~/Documents/notes/Notes/{feature}-test.txt`
- Use `.txt` extension, NOT `.md`
- Clean up test files after suite completion

### 2.5 Console Logging for Tests
- **All event handlers must log execution**
  ```typescript
  const handleDragEnd = (event) => {
    console.log('handleDragEnd called:', { /* context */ });
    // implementation
  };
  ```
- **Tests must capture and validate console output**
- **No errors allowed in console during tests**

---

## 3. User Experience Consistency

### 3.1 UI/UX Principles
- **Keyboard-First Design**
  - All features must be accessible via keyboard
  - Shortcuts must be discoverable (show in tooltips/command palette)
  - Tab order must be logical and intuitive

- **Instant Feedback**
  - User actions must provide immediate visual feedback
  - Loading states for operations >200ms
  - Error messages must appear inline, not in alerts
  - Success confirmations must be subtle (toast, checkmark)

- **NotePlan Compatibility**
  - Match NotePlan's markdown syntax and behavior
  - Support NotePlan keyboard shortcuts where applicable
  - File format must be compatible with NotePlan

### 3.2 Visual Consistency
- **Design System**
  - Use Tailwind CSS utility classes consistently
  - Maintain theme system (Light, Dark, Ocean)
  - All colors must work in all themes

- **Component Standards**
  - Buttons: Consistent sizing, padding, and hover states
  - Inputs: Consistent focus rings and error states
  - Cards: Consistent shadows, borders, and spacing
  - Typography: Consistent font sizes and line heights

### 3.3 Accessibility (a11y)
- **WCAG 2.1 AA Compliance**
  - Minimum contrast ratio: 4.5:1 for text
  - All interactive elements must be keyboard accessible
  - ARIA labels for screen readers where needed
  - Focus indicators must be visible

- **Semantic HTML**
  - Use proper heading hierarchy (h1, h2, h3)
  - Use semantic elements (nav, main, article)
  - Avoid `div` soup - use meaningful tags

---

## 4. Performance Requirements

### 4.1 Loading Performance
- **Initial Page Load**
  - First Contentful Paint (FCP): <1.5s
  - Time to Interactive (TTI): <3.0s
  - Largest Contentful Paint (LCP): <2.5s

- **File Operations**
  - File open: <300ms for files <100KB
  - File save: <200ms (debounced)
  - File list load: <500ms for <1000 files

### 4.2 Runtime Performance
- **Rendering**
  - Maintain 60fps during interactions
  - No jank during scrolling
  - Debounce expensive operations (search, auto-save)

- **Memory Management**
  - Clean up event listeners on unmount
  - Unsubscribe from stores on unmount
  - Limit DOM nodes for large lists (virtualization)

### 4.3 Optimization Strategies
- **Code Splitting**
  - Lazy load routes
  - Lazy load heavy components (Kanban, Calendar)
  - Dynamic imports for infrequently used features

- **Caching**
  - Cache parsed markdown files
  - Cache file system operations
  - Implement LRU cache for recently accessed notes

- **Debouncing/Throttling**
  - Auto-save: debounce 1000ms
  - Search: debounce 300ms
  - File watcher events: throttle 100ms

### 4.4 Bundle Size
- **Production Build**
  - Total bundle: <500KB gzipped
  - Vendor bundle: <300KB gzipped
  - Monitor bundle size on each build
  - No duplicate dependencies

---

## 5. Data Integrity Standards

### 5.1 File Format Integrity
- **Markdown Format**
  - Use GitHub Flavored Markdown (GFM) as standard
  - Task format: `- [ ] Task` (GFM), NOT `[] Task` (legacy)
  - Support legacy format for backward compatibility
  - Auto-migrate legacy format on file open

- **File Naming**
  - Use `.txt` extension, NOT `.md`
  - Location: `~/Documents/notes/Notes/`
  - Filename format: kebab-case or spaces allowed
  - No special characters except `-`, `_`, spaces

### 5.2 Data Persistence
- **Save Strategy**
  - Debounce auto-save to prevent race conditions
  - Atomic writes (write to temp file, then rename)
  - Verify write success before confirming to user
  - Handle concurrent edits (file watcher updates)

- **Data Validation**
  - Validate markdown syntax before save
  - Preserve user content even if parsing fails
  - Log parsing errors without blocking save

### 5.3 Backward Compatibility
- **Legacy Format Support**
  - Read legacy NotePlan format (`[] Task`)
  - Auto-migrate to GFM format (`- [ ] Task`)
  - Preserve unknown markdown extensions
  - Never delete user data during migration

---

## 6. Architecture Principles

### 6.1 Separation of Concerns
- **Presentation vs Logic**
  - Components: UI rendering only
  - Services: Business logic and data access
  - Stores: State management
  - Extensions: Editor behavior

- **Data Flow**
  - Unidirectional data flow (Zustand stores)
  - Props down, events up (React best practices)
  - No prop drilling (use context or stores for deep data)

### 6.2 Dependency Management
- **Keep Dependencies Minimal**
  - Justify new dependencies in PRPs
  - Prefer native solutions over libraries
  - Audit dependencies for security vulnerabilities
  - Pin versions for production dependencies

- **Version Control**
  - Use exact versions for critical dependencies
  - Document breaking changes in package.json comments
  - Test before upgrading major versions

### 6.3 API Design
- **RESTful Backend**
  - Use semantic HTTP methods (GET, POST, PUT, DELETE)
  - Consistent URL structure (`/api/notes/:id`)
  - Return proper status codes
  - Include error details in response body

- **WebSocket Communication**
  - Use Socket.IO for real-time updates
  - Handle reconnection gracefully
  - Throttle events to prevent flooding

---

## 7. Security Standards

### 7.1 Input Validation
- **Sanitize All Inputs**
  - Validate file paths (prevent directory traversal)
  - Sanitize markdown content (prevent XSS)
  - Validate task data before save
  - Escape special characters in search queries

### 7.2 File System Security
- **Restrict File Access**
  - Only allow access to `~/Documents/notes/Notes/`
  - Validate paths before read/write
  - No execution of user-provided code
  - Limit file size to prevent DoS

### 7.3 Client-Side Security
- **Content Security Policy**
  - No inline scripts (use Vite's CSP)
  - No eval() or Function() constructor
  - Sanitize user-generated HTML
  - Use DOMPurify for markdown rendering if needed

---

## 8. Git Workflow Standards

### 8.1 Commit Standards
- **Conventional Commits**
  - Format: `type(scope): description`
  - Types: `feat`, `fix`, `refactor`, `test`, `docs`, `chore`
  - Examples:
    - `feat(tasks): Add GFM format support`
    - `fix(editor): Preserve task newlines on save`
    - `test(tasks): Add round-trip task persistence test`

### 8.2 Branch Strategy
- **Main branch:** Production-ready code
- **Feature branches:** `feature/{feature-name}`
- **Bug fixes:** `fix/{bug-name}`
- **Merge strategy:** Squash and merge for features

### 8.3 Code Review
- **All changes require:**
  - Passing automated tests
  - TypeScript type checking
  - No console errors
  - Updated documentation (if applicable)

---

## 9. Documentation Standards

### 9.1 Code Documentation
- **README.md:** User-facing getting started guide
- **CLAUDE.md:** Developer reference (this file)
- **API_DOCUMENTATION.md:** Backend API reference
- **PRPs/:** Product Requirement Plans for features

### 9.2 Documentation Updates
- **When to Update:**
  - New features: Update CLAUDE.md, create PRP
  - Bug fixes: Update "Updates Log" in CLAUDE.md
  - API changes: Update API_DOCUMENTATION.md
  - Breaking changes: Update README.md and migration guide

### 9.3 PRP (Product Requirement Plan) Standards
- **Every significant feature requires a PRP**
- **PRP Structure:**
  1. Problem statement
  2. Proposed solution
  3. Technical approach
  4. Test plan
  5. Migration strategy (if applicable)

---

## 10. Continuous Improvement

### 10.1 Performance Monitoring
- **Track Metrics:**
  - Bundle size on each build
  - Test suite execution time
  - File operation timing
  - Memory usage during long sessions

### 10.2 Technical Debt
- **Manage Debt Proactively:**
  - Document TODOs with context
  - Create issues for known limitations
  - Allocate time for refactoring
  - Prioritize high-impact debt

### 10.3 Learning from Failures
- **Post-Mortem for Major Bugs:**
  - Document root cause
  - Add regression test
  - Update constitution if needed
  - Share learnings in PRPs

---

## 11. Enforcement

### 11.1 Pre-Commit Checks
- [ ] TypeScript type checking passes
- [ ] No console.error or console.warn in production code
- [ ] Linting passes (when configured)
- [ ] File naming conventions followed

### 11.2 Pre-Merge Checks
- [ ] All automated tests pass
- [ ] Feature tested in all themes
- [ ] No TypeScript errors
- [ ] Documentation updated
- [ ] PRP created (if applicable)

### 11.3 Constitution Updates
- This constitution is a living document
- Updates require justification and discussion
- Breaking changes require migration plan
- All updates logged in git history

---

## 🎯 Summary: Core Tenets

1. **Quality > Speed:** Take time to do it right
2. **Test Everything:** Automated tests are non-negotiable
3. **User First:** Prioritize UX and accessibility
4. **Data Integrity:** Never lose user data
5. **Type Safety:** Strong types prevent bugs
6. **Document Decisions:** Future you will thank you
7. **Measure Performance:** What gets measured gets improved
8. **Continuous Improvement:** Always be refactoring

---

**Last Updated:** 2025-10-22
**Version:** 1.0.0
**Status:** Active
